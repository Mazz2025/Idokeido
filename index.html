<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>住所から緯度経度、最寄り駅を取得</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PapaParse CDN for CSV parsing (used for city codes data) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <!-- Google Fonts - LXGW Marker Gothic -->
    <link href="https://fonts.googleapis.com/css2?family=LXGW+Marker+Gothic&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for better content display */
            min-height: 100vh;
            padding: 2rem;
        }
        .container {
            background-color: #ffffff;
            padding: 2.5rem;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 900px;
            width: 100%;
            /* margin-top removed as version display is now inside */
        }
        .btn {
            @apply px-6 py-3 rounded-lg text-white font-semibold transition-all duration-300 ease-in-out;
            @apply shadow-md hover:shadow-lg focus:outline-none focus:ring-4 focus:ring-opacity-75;
        }
        .btn-primary {
            @apply bg-blue-600 hover:bg-blue-700 focus:ring-blue-500;
        }
        .btn-success {
            @apply bg-green-600 hover:bg-green-700 focus:ring-green-500;
        }
        .btn-danger {
            @apply bg-red-600 hover:bg-red-700 focus:ring-red-500;
        }
        .btn-secondary {
            @apply bg-gray-500 hover:bg-gray-600 focus:ring-gray-400;
        }
        .btn-disabled {
            @apply bg-gray-400 cursor-not-allowed;
        }
        input[type="file"] {
            @apply block w-full text-sm text-gray-900 border border-gray-300 rounded-lg cursor-pointer bg-gray-50 focus:outline-none;
        }
        input[type="text"], select {
            @apply block w-full px-4 py-2 text-gray-900 border border-gray-300 rounded-lg bg-gray-50 focus:ring-blue-500 focus:border-blue-500;
        }
        .message-box {
            @apply p-4 mt-4 rounded-lg;
        }
        .message-info {
            @apply bg-blue-100 text-blue-800;
        }
        .message-success {
            @apply bg-green-100 text-green-800;
        }
        .message-error {
            @apply bg-red-100 text-red-800;
        }
        .message-warning {
            @apply bg-yellow-100 text-yellow-800;
        }
        /* Custom style for the title font */
        #appTitle {
            font-family: 'LXGW Marker Gothic', cursive;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Version Display - Moved back inside container -->
        <div id="appVersionDisplay" class="text-right text-gray-500 text-xs mb-2"></div>
        <h1 id="appTitle" class="text-6xl font-bold text-gray-800 mb-6 text-center">イドケイド+</h1>

        <div class="mb-6 bg-blue-50 p-4 rounded-lg shadow-sm">
            <h2 class="text-xl font-semibold text-blue-800 mb-3">はじめに</h2>
            <p class="text-gray-700 mb-2">
                「イドケイド＋」は、CSVファイルに記載された住所からその場所の緯度・経度（位置情報）と最寄り駅を自動で調べ、新しいCSVファイルとして出力するツールです。
            </p>
            <p class="text-gray-700 mb-2">
                CSVファイルは「カンマ区切り形式（.csv）」でアップロードしてください。<br>
                Googleスプレッドシートをお使いの場合：<br>
                「ファイル」→「ダウンロード」→「カンマ区切り形式（.csv）」を選んで保存してください。
            </p>
            <p class="text-gray-700 text-sm mt-3">
                <span class="font-bold">【ツールの特徴】</span><br>
                住所から自動的に緯度・経度を取得し、その地点から最も近い駅名を自動で検索します。<br>
                情報が見つからなかった場合は、「不明」と表示されます。
            </p>
        </div>

        <div class="mb-4">
            <label for="csvFile" class="block text-gray-700 text-sm font-bold mb-2">CSVファイルをアップロード:</label>
            <input type="file" id="csvFile" accept=".csv" class="mb-4">
            <button id="clearFileButton" class="btn btn-secondary text-sm px-4 py-2 mt-2">ファイルの選択をクリア</button>
        </div>

        <div class="mb-4">
            <label for="encodingSelect" class="block text-gray-700 text-sm font-bold mb-2">文字コード:</label>
            <select id="encodingSelect" class="mb-4">
                <option value="UTF-8">UTF-8 (推奨)</option>
                <option value="Shift_JIS">Shift-JIS</option>
            </select>
        </div>

        <div id="headerDisplay" class="mb-4 p-3 bg-gray-100 rounded-lg hidden">
            <p class="text-gray-700 text-sm font-bold mb-2">認識されたヘッダー:</p>
            <code id="parsedHeaders" class="block bg-gray-200 p-2 rounded-md text-sm text-gray-800 break-all"></code>
        </div>

        <div class="mb-6">
            <label for="addressColumn" class="block text-gray-700 text-sm font-bold mb-2">住所の列名（例: 住所, Address）:</label>
            <input type="text" id="addressColumn" placeholder="例: 住所" class="mb-4">
        </div>

        <div class="mb-6">
            <label for="kanaSuffixInput" class="block text-gray-700 text-sm font-bold mb-2">店舗名(カナ)に付与する文字列（空欄の場合は何も付与しません）:</label>
            <input type="text" id="kanaSuffixInput" placeholder="例: PMK" class="mb-4">
        </div>

        <!-- 新しい出力形式選択の追加 -->
        <div class="mb-4">
            <label for="outputFormatSelect" class="block text-gray-700 text-sm font-bold mb-2">出力形式を選択:</label>
            <select id="outputFormatSelect" class="mb-4">
                <option value="PILOT">PILOT用</option>
                <option value="RMSA">RMSA用</option>
            </select>
        </div>
        <!-------------------------------->

        <div class="flex flex-col sm:flex-row gap-4 mb-6">
            <button id="geocodeButton" class="btn btn-primary flex-1" disabled>緯度経度と最寄り駅を取得</button>
            <button id="cancelButton" class="btn btn-danger flex-1 hidden" disabled>キャンセル</button>
            <button id="downloadCsvButton" class="btn btn-success flex-1" disabled>CSVをダウンロード</button>
        </div>

        <!-- Excelでのゼロ欠落に関する注意書き -->
        <div id="excelWarning" class="message-box message-warning text-sm mt-2">
            <p class="font-bold">【ダウンロードファイルを開く際の注意】</p>
            <p>ダウンロードしたCSVファイルをExcelで直接開くと、郵便番号や市区町村コードなどの先頭の「0」が消える場合があります。</p>
            <p>これはExcelの自動変換によるものです。ゼロを保持するには、以下のいずれかの方法で開いてください:</p>
            <ul class="list-disc list-inside ml-4 mt-1">
                <li>メモ帳やテキストエディタで開く。</li>
                <li>Excelの「データ」タブ → 「データを取り込み」 → 「テキストまたはCSVから」を選択し、インポートウィザードで列のデータ形式を「テキスト」に指定して取り込む。</li>
            </ul>
        </div>
        
        <div id="messageBox" class="message-box message-info hidden">
            <p id="messageText"></p>
        </div>

        <div id="progressBarContainer" class="w-full bg-gray-200 rounded-full h-4 mt-6 hidden">
            <div id="progressBar" class="bg-blue-600 h-4 rounded-full text-xs text-white flex items-center justify-center" style="width: 0%">
                <span id="progressText">0%</span>
            </div>
        </div>
    </div>

    <script>
        // --- アプリケーションバージョン情報 ---
        const APP_VERSION = "v1.6.9"; // ここでバージョンを管理

        // HTML内のバージョン表示を更新
        document.addEventListener('DOMContentLoaded', () => {
            const versionDisplay = document.getElementById('appVersionDisplay');
            if (versionDisplay) {
                versionDisplay.textContent = `バージョン: ${APP_VERSION}`;
            }
        });


        // DOM要素の取得
        const csvFileInput = document.getElementById('csvFile');
        const clearFileButton = document.getElementById('clearFileButton');
        const encodingSelect = document.getElementById('encodingSelect');
        const addressColumnInput = document.getElementById('addressColumn');
        const kanaSuffixInput = document.getElementById('kanaSuffixInput'); // 新しい入力フィールドを取得
        const outputFormatSelect = document.getElementById('outputFormatSelect'); // 追加: 出力形式選択
        const geocodeButton = document.getElementById('geocodeButton');
        const cancelButton = document.getElementById('cancelButton'); // キャンセルボタンを追加
        const downloadCsvButton = document.getElementById('downloadCsvButton');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBar = document.getElementById('progressBar');
        const headerDisplay = document.getElementById('headerDisplay');
        const parsedHeadersText = document.getElementById('parsedHeaders');

        let parsedData = []; // パースされたCSVデータを保持
        let headers = [];    // CSVヘッダーを保持
        let resultData = []; // 緯度経度と最寄り駅を追加した結果データを保持
        let stationsData = []; // 駅マスターデータを保持
        let cityCodesData = []; // 市区町村コードマスターデータを保持
        let isProcessingCancelled = false; // 処理中断フラグ
        // 曖昧な駅名を保持するSet。異なる都道府県に存在する同名駅が格納される
        let ambiguousStationNames = new Set(); 

        // --- 駅データのURLを指定 (ここをあなたのRaw URLに置き換える必要があります！) ---
        // 例: 'https://raw.githubusercontent.com/your-username/your-repo/main/N02-20_Station.geojson'
        const stationsDataUrl = 'https://raw.githubusercontent.com/Mazz2025/Idokeido/main/N02-20_Station.geojson'; 

        // --- 市区町村コードデータのURLを指定 (ここをあなたのRaw URLに置き換える必要があります！) ---
        // 例: 'https://raw.githubusercontent.com/Mazz2025/Idokeido/refs/heads/main/city-codes.csv'
        const cityCodesDataUrl = 'https://raw.githubusercontent.com/Mazz2025/Idokeido/refs/heads/main/city-codes.csv'; 

        // --- 出力CSVファイルのヘッダー定義 ---
        const PILOT_HEADERS = [
            '企業コード', '店舗コード', 'ロケール', '店舗名(漢字)', '店舗名(カナ)', '請求先コード1',
            '請求先コード2', '使用不可フラグ', '郵便番号', 'L2コード', '市区町村コード',
            '国交省住所1', 
            '国交省住所2', '国交省住所補足', '住所1', '住所2', '住所3', '電話番号', 'FAX番号',
            '担当部門', '担当者役職', '担当者名', '担当者MAIL', '代表業態コード', '業態中分類コード',
            '旧業態コード', '旧業態コード中分類', '顧客側店舗コード', '管轄DOコード', '緯度', '経度',
            '鉄道最寄駅', 
            'バス最寄駅', '添付ファイルコード', 'ファイル名', 'ファイルアップロード日',
            'SEJDO名', '免許品', '実績年月日1', '実績作業量1', '実績年月日2', '実績作業量2',
            '実績年月日3', '実績作業量3', '登録日時', '登録ユーザID', '更新日時', '更新ユーザID'
        ];

        const RMSA_HEADERS = [
            '企業CD', '店舗CD', '店舗名', '顧客側店舗CD', '郵便番号', '住所1', '住所2', '住所3',
            '電話番号', 'FAX番号', '最寄り駅', '最寄りバス停', '削除フラグ', '緯度', '経度'
        ];

        // 都道府県コードと都道府県名のマッピング (今回は直接使用しないが、参考として残す)
        const PREFECTURE_CODES = {
            "01": "北海道", "02": "青森県", "03": "岩手県", "04": "宮城県", "05": "秋田県",
            "06": "山形県", "07": "福島県", "08": "茨城県", "09": "栃木県", "10": "群馬県",
            "11": "埼玉県", "12": "千葉県", "13": "東京都", "14": "神奈川県", "15": "新潟県",
            "16": "富山県", "17": "石川県", "18": "福井県", "19": "山梨県", "20": "長野県",
            "21": "岐阜県", "22": "静岡県", "23": "愛知県", "24": "三重県", "25": "滋賀県",
            "26": "京都府", "27": "大阪府", "28": "兵庫県", "29": "奈良県", "30": "和歌山県",
            "31": "鳥取県", "32": "島根県", "33": "岡山県", "34": "広島県", "35": "山口県",
            "36": "徳島県", "37": "香川県", "38": "愛媛県", "39": "高知県", "40": "福岡県",
            "41": "佐賀県", "42": "長崎県", "43": "熊本県", "44": "大分県", "45": "宮崎県",
            "46": "鹿児島県", "47": "沖縄県"
        };

        // 遅延関数
        const delay = ms => new Promise(res => setTimeout(res, ms));


        // アプリ起動時にマスターデータ（駅データ、市区町村コードデータ）を読み込む
        window.onload = async () => {
            let stationsDataLoaded = false;
            let cityCodesDataLoaded = false;

            // 駅データ読み込み
            if (!stationsDataUrl.startsWith('http')) {
                showMessage('警告: 駅データのURLが設定されていません。最寄り駅検索機能は利用できません。', 'error');
            } else {
                await loadStationsData();
                if (stationsData.length > 0) stationsDataLoaded = true;
            }

            // 市区町村コードデータ読み込み
            if (!cityCodesDataUrl.startsWith('http') || cityCodesDataUrl === 'YOUR_RAW_CITY_CODES_CSV_URL_HERE') {
                showMessage('警告: 市区町村コードデータのURLが設定されていません。市区町村コードの取得機能は利用できません。コード内の `cityCodesDataUrl` 変数を正しいURLに置き換えてください。', 'error');
            } else {
                await loadCityCodesData();
                if (cityCodesData.length > 0) cityCodesDataLoaded = true;
                // 市区町村コードデータが少ない場合の警告
                if (cityCodesData.length > 0 && cityCodesData.length < 1700) { // 参考：全国の市区町村数は1700以上
                    showMessage(`警告: 市区町村コードデータは読み込まれましたが、全国の全ての市区町村が含まれていない可能性があります（現在 ${cityCodesData.length} 件）。処理しようとしている住所の市区町村が含まれているかご確認ください。`, 'warning');
                }
            }
            
            // 全ての必須データが読み込まれたらボタンを有効化
            if (stationsDataLoaded || cityCodesDataLoaded) { // どちらか片方でもロードされていればCSVアップロードは可能
                showMessage('アプリが起動しました。CSVファイルをアップロードしてください。');
                csvFileInput.disabled = false;
                geocodeButton.disabled = false; // 処理開始ボタンを有効化
            } else {
                showMessage('必要なデータ（駅または市区町村コード）を読み込めませんでした。CSVのアップロードと処理はできません。', 'error');
                csvFileInput.disabled = true;
                geocodeButton.disabled = true;
            }
            
            cancelButton.classList.add('hidden'); // 初期状態ではキャンセルボタンは非表示
            downloadCsvButton.disabled = true; // 初期状態ではダウンロードボタンは無効
        };

        // メッセージ表示関数
        function showMessage(text, type = 'info') {
            messageBox.classList.remove('hidden', 'message-info', 'message-success', 'message-error', 'message-warning'); // 全てのタイプをリセット
            messageBox.classList.add('p-4', 'mt-4', 'rounded-lg'); // スタイルを再適用
            messageText.textContent = text;
            if (type === 'info') {
                messageBox.classList.add('bg-blue-100', 'text-blue-800');
            } else if (type === 'success') {
                messageBox.classList.add('bg-green-100', 'text-green-800');
            } else if (type === 'error') {
                messageBox.classList.add('bg-red-100', 'text-red-800');
            } else if (type === 'warning') {
                messageBox.classList.add('bg-yellow-100', 'text-yellow-800');
            }
            messageBox.classList.remove('hidden'); // メッセージボックスを表示
        }

        // プログレスバー表示関数
        function updateProgressBar(progress) {
            progressBarContainer.classList.remove('hidden');
            progressBar.style.width = `${progress}%`;
            progressText.textContent = `${Math.round(progress)}%`;
        }

        // CSVファイル読み込みイベントリスナー
        csvFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                // ファイル選択がキャンセルされた場合、現在の状態を維持
                return;
            }

            const reader = new FileReader();
            const encoding = encodingSelect.value; // 選択された文字コードを取得

            reader.onload = (e) => {
                const text = e.target.result;
                try {
                    parseCsv(text);
                    showMessage('CSVファイルが読み込まれました。');
                    // 駅データまたは市区町村コードデータが読み込まれていればボタンを有効に
                    if (stationsData.length > 0 || cityCodesData.length > 0) {
                         geocodeButton.disabled = false;
                    } else {
                         showMessage('必要なデータ（駅または市区町村コード）が読み込まれていないため、処理できません。', 'warning');
                         geocodeButton.disabled = true;
                    }
                    downloadCsvButton.disabled = true; // 新しいファイルを読み込んだらダウンロードボタンを無効化
                    progressBarContainer.classList.add('hidden'); // プログレスバーをリセット
                    headerDisplay.classList.remove('hidden'); // ヘッダー表示を常に表示
                } catch (error) {
                    showMessage('CSVのパース中にエラーが発生しました。ファイル形式または文字コードが正しくない可能性があります。', 'error');
                    console.error("CSV parsing error:", error);
                    geocodeButton.disabled = true;
                    headerDisplay.classList.add('hidden'); // エラー時はヘッダー表示を隠す
                }
            };
            reader.onerror = () => {
                showMessage('ファイルの読み込み中にエラーが発生しました。選択した文字コードが正しくない可能性があります。', 'error');
                geocodeButton.disabled = true;
                headerDisplay.classList.add('hidden'); // エラー時はヘッダー表示を隠す
            };
            reader.readAsText(file, encoding); // 選択された文字コードで読み込む
        });

        // ファイル選択クリアボタンイベントリスナー
        clearFileButton.addEventListener('click', () => {
            csvFileInput.value = ''; // ファイル選択をクリア
            parsedData = [];
            headers = [];
            resultData = [];
            addressColumnInput.value = ''; // 住所列名もクリア
            parsedHeadersText.textContent = ''; // 認識されたヘッダーをクリア
            headerDisplay.classList.add('hidden'); // ヘッダー表示を隠す
            showMessage('ファイルの選択がクリアされました。', 'info');
            geocodeButton.disabled = true; // クリアしたらジオコーディングボタンも無効化
            downloadCsvButton.disabled = true;
            cancelButton.classList.add('hidden'); // キャンセルボタンも非表示に
            progressBarContainer.classList.add('hidden'); // プログレスバーを隠す
            // 必須データが読み込まれている場合はジオコーディングボタンを再度有効にする
            if (stationsData.length > 0 || cityCodesData.length > 0) {
                geocodeButton.disabled = false;
                showMessage('ファイルの選択がクリアされました。新しいCSVファイルをアップロードしてください。');
            }
        });


        // CSVパース関数
        function parseCsv(csvText) {
            const lines = csvText.split(/\r?\n/).filter(line => line.trim() !== ''); // 空行を除去
            if (lines.length === 0) {
                parsedData = [];
                headers = [];
                parsedHeadersText.textContent = ''; // ヘッダー表示をクリア
                headerDisplay.classList.add('hidden'); // ヘッダー表示を隠す
                throw new Error("CSVファイルが空またはデータがありません。");
            }
            // 区切り文字の自動判別（カンマ、セミコロン、タブ）
            let separator = ',';
            if (lines[0].includes(';')) {
                separator = ';';
            } else if (lines[0].includes('\t')) {
                separator = '\t';
            }

            headers = lines[0].split(separator).map(h => h.trim()); // ヘッダーをトリム
            parsedData = lines.slice(1).map(line => {
                const values = line.split(separator);
                const row = {};
                headers.forEach((header, i) => {
                    row[header] = values[i] ? values[i].trim() : ''; // 行のデータもトリム
                });
                return row;
            });

            // 認識されたヘッダーを表示
            parsedHeadersText.textContent = JSON.stringify(headers);
            headerDisplay.classList.remove('hidden');
        }

        /**
         * 住所の「1-2-3」のような表記を「1丁目2番3号」のように変換し、全角数字・ハイフンを半角にするヘルパー関数。
         * この関数は、主に国土地理院APIでの緯度経度取得の精度を向上させるために使用されます。
         *
         * @param {string} address - 元の住所文字列。
         * @returns {string} 変換された住所文字列。
         */
        function normalizeAddressHyphens(address) {
            let tempAddress = String(address).normalize('NFKC'); // NFKC正規化を先行
            
            console.log(`normalizeAddressHyphens: Step 1 (NFKC Normalized): "${tempAddress}"`);

            // 明示的に全角数字を半角に変換（NFKCでカバーされるが念のため）
            tempAddress = tempAddress.replace(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
            console.log(`normalizeAddressHyphens: Step 2 (Half-width digits explicit): "${tempAddress}"`);

            // 全角ハイフンマイナスと長音符を半角ハイフンに変換 (Unicodeエスケープで確実化)
            tempAddress = tempAddress.replace(/[\uFF0D\u30FC]/g, '-'); 
            console.log(`normalizeAddressHyphens: Step 3 (Half-width hyphens explicit): "${tempAddress}"`);

            // Rule 1: "数字丁目"の後の"数字-数字"パターンを"数字番数字号"に変換
            // 例: "西葛西3丁目15-12" -> "西葛西3丁目15番12号"
            tempAddress = tempAddress.replace(/(\d+丁目)(\d+)-(\d+)(?![番号])/g, (match, p1, p2, p3) => {
                return `${p1}${p2}番${p3}号`;
            });

            // Rule 2: 一般的な"数字-数字-数字"パターンを"数字丁目数字番数字号"に変換
            // 例: "1-2-3" -> "1丁目2番3号"
            tempAddress = tempAddress.replace(/(?<![丁番号])(\d+)-(\d+)-(\d+)(?![丁番号])/g, (match, p1, p2, p3) => {
                return `${p1}丁目${p2}番${p3}号`;
            });

            // Rule 3: 一般的な"数字-数字"パターンを"数字番数字号"に変換
            // 例: "15-12" (丁目などが先行しない場合) -> "15番12号"
            tempAddress = tempAddress.replace(/(?<![丁番号])(\d+)-(\d+)(?![丁番号])/g, (match, p1, p2) => {
                return `${p1}番${p2}号`;
            });
            
            // Rule 4: 最後に、数字の後に「号」がない場合に「号」を追加 (文末に限定)
            tempAddress = tempAddress.replace(/(\d+)(?![丁番号])$/, '$1号');
            console.log(`normalizeAddressHyphens: Final normalized address: "${tempAddress}"`);

            return tempAddress;
        }

        /**
         * 全角ひらがな、全角カタカナ、全角数字、一部記号を半角カタカナに変換する関数
         * (v1.0.2 のロジックに戻しました)
         * @param {string} str - 変換する文字列
         * @returns {string} 半角カタカナに変換された文字列
         */
        function toHalfWidthKatakana(str) {
            if (!str) return '';
            let tempStr = String(str);

            // 1. 全角ひらがなを全角カタカナに変換
            tempStr = tempStr.replace(/[\u3040-\u309F]/g, function(s) {
                return String.fromCharCode(s.charCodeAt(0) + 0x60);
            });

            // 2. 全角カタカナを半角カタカナに変換するためのマッピングテーブル
            const halfWidthMap = {
                'ア': 'ｱ', 'イ': 'ｲ', 'ウ': 'ｳ', 'エ': 'ｴ', 'オ': 'ｵ',
                'カ': 'ｶ', 'キ': 'ｷ', 'ク': 'ｸ', 'ケ': 'ｹ', 'コ': 'ｺ',
                'サ': 'ｻ', 
                'シ': 'ｼ', 'ス': 'ｽ', 'セ': 'ｾ', 'ソ': 'ｿ', 
                'タ': 'ﾀ', 'チ': 'ﾁ', 'ツ': 'ﾂ', 'テ': 'ﾃ', 'ト': 'ﾄ',
                'ナ': 'ﾅ', 'ニ': 'ﾆ', 'ヌ': 'ﾇ', 'ネ': 'ﾈ', 'ノ': 'ﾉ',
                'ハ': 'ﾊ', 'ヒ': 'ﾋ', 'フ': 'ﾌ', 'ヘ': 'ﾍ', 'ホ': 'ホ',
                'マ': 'ﾏ', 'ミ': 'ﾐ', 'ム': 'ﾑ', 'メ': 'ﾒ', 'モ': 'ﾓ',
                'ヤ': 'ﾔ', 'ユ': 'ﾕ', 'ヨ': 'ﾖ', 
                'ラ': 'ﾗ', 'リ': 'ﾘ', 'ル': 'ﾙ', 'レ': 'ﾚ', 'ロ': 'ﾛ', 
                'ワ': 'ﾜ', 'ヲ': 'ｦ', 'ン': 'ﾝ',
                'ァ': 'ｧ', 'ィ': 'ｨ', 'ゥ': 'ｩ', 'ェ': 'ｪ', 'ォ': 'ｫ',
                'ャ': 'ｬ', 'ュ': 'ｭ', 'ョ': 'ｮ', 'ッ': 'ｯ',
                'ガ': 'ｶﾞ', 'ギ': 'ｷﾞ', 'グ': 'ｸﾞ', 'ゲ': 'ｹﾞ', 'ゴ': 'ｺﾞ',
                'ザ': 'ｻﾞ', 'ジ': 'ｼﾞ', 'ズ': 'ｽﾞ', 'ゼ': 'ｾﾞ', 'ゾ': 'ｿﾞ',
                'ダ': 'ﾀﾞ', 'ヂ': 'ﾁﾞ', 'ヅ': 'ﾂﾞ', 'デ': 'ﾃﾞ', 'ド': 'ﾄﾞ',
                'バ': 'ﾊﾞ', 'ビ': 'ﾋﾞ', 'ブ': 'ﾌﾞ', 'ベ': 'ﾍﾟ', 'ボ': 'ﾎﾞ',
                'パ': 'ﾊﾟ', 'ピ': 'ﾋﾟ', 'プ': 'ﾌﾟ', 'ペ': 'ﾍﾟ', 'ポ': 'ﾎﾟ',
                'ヴ': 'ｳﾞ', 'ヵ': 'ｶ', 'ヶ': 'ｹ',
                'ー': 'ｰ', // 長音符
                '０': '0', '１': '1', '２': '2', '３': '3', '４': '4',
                '５': '5', '６': '6', '７': '7', '８': '8', '９': '9', // 全角数字
                '　': ' ', // 全角スペース
                '！': '!', '？': '?', '、': '､', '。': '｡', '「': '｢', '」': '｣', '・': '･' // その他の記号
                // 以下はNFKCで処理されない可能性のある結合文字の直接マッピング
                // '゛': 'ﾞ', '゜': 'ﾟ'
            };

            let converted = '';
            for (let i = 0; i < tempStr.length; i++) {
                let char = tempStr[i];
                converted += halfWidthMap[char] || char; // マッピングがあれば変換、なければそのまま
            }
            return converted;
        }


        /**
         * 住所文字列から直接郵便番号を抽出する関数。
         * @param {string} address - 住所文字列。
         * @returns {string} 抽出された7桁の郵便番号（ハイフンあり「000-0000」形式）または空文字列。
         */
        function extractPostalCodeFromAddressString(address) {
            if (!address) return '';

            let normalizedAddress = String(address).normalize('NFKC'); // NFKC正規化を先行

            normalizedAddress = normalizedAddress.replace(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
            normalizedAddress = normalizedAddress.replace(/[\uFF0D\u30FC]/g, '-'); // 修正: 全角ハイフンマイナスと長音符の両方を変換
            console.log(`extractPostalCodeFromAddressString: Normalized address for direct extraction: "${normalizedAddress}"`);

            // 7桁の数字（ハイフンあり/なし）の郵便番号を検索
            const postcodeRegex = /(\d{3}[-]?\d{4})/;
            const postcodeMatch = normalizedAddress.match(postcodeRegex);
            console.log(`extractPostalCodeFromAddressString: Postcode regex match result:`, postcodeMatch);

            if (postcodeMatch && postcodeMatch[1]) {
                const postalCode = postcodeMatch[1].replace(/-/g, ''); // ハイフンを除去
                const formattedPostalCode = postalCode.padStart(7, '0'); // 7桁にゼロ埋め
                return formattedPostalCode.substring(0, 3) + '-' + formattedPostalCode.substring(3);
            }
            console.log(`extractPostalCodeFromAddressString: No postal code found directly in address string: "${address}"`);
            return ''; // 見つからなければ空文字列
        }

        /**
         * HeartRails Geo API を使用して緯度経度から郵便番号を取得する関数。
         * @param {number} latitude - 緯度。
         * @param {number} longitude - 経度。
         * @returns {Promise<string>} 検索された郵便番号（7桁、ゼロ埋め、ハイフンあり「000-0000」形式）または空文字列を解決するPromise。
         */
        async function getPostalCodeFromHeartRailsAPI(latitude, longitude) {
            if (latitude === null || longitude === null || isNaN(latitude) || isNaN(longitude)) {
                console.warn(`HeartRails API: 無効な緯度経度のため、API呼び出しをスキップします。Lat: ${latitude}, Lon: ${longitude}`);
                return '';
            }

            const baseUrl = 'https://geoapi.heartrails.com/api/json'; 
            // HeartRails APIはx（経度）、y（緯度）で受け取る
            const queryParams = new URLSearchParams({
                method: 'searchByGeoLocation', 
                x: longitude,
                y: latitude
            });
            const apiUrl = `${baseUrl}?${queryParams.toString()}`;
            console.log(`HeartRails API: Calling API with URL: ${apiUrl}`);

            try {
                const response = await fetch(apiUrl);
                const data = await response.json();
                console.log(`HeartRails API レスポンス (Lat: ${latitude}, Lon: ${longitude}):`, data);

                if (response.ok && data.response && Array.isArray(data.response.location) && data.response.location.length > 0) {
                    for (const loc of data.response.location) {
                        if (loc.postal) { 
                            const postalCode = String(loc.postal).padStart(7, '0');
                            return postalCode.substring(0, 3) + '-' + postalCode.substring(3);
                        }
                    }
                    console.warn(`HeartRails API: 緯度経度 (${latitude}, ${longitude}) に対応する有効な郵便番号が見つかりませんでした。レスポンス内のlocation要素のいずれにもpostal情報がありませんでした。レスポンス: ${JSON.stringify(data)}`);
                    return '';
                } else {
                    console.warn(`HeartRails API: 緯度経度 (${latitude}, ${longitude}) に対応する郵便番号が見つかりませんでした。レスポンス構造が不正またはデータがありません。レスポンス: ${JSON.stringify(data)}`);
                    return '';
                }
            } catch (error) {
                console.error(`HeartRails API 呼び出しエラー (Lat: ${latitude}, Lon: ${longitude}):`, error);
                return '';
            }
        }

        /**
         * 住所文字列を「都道府県＋市区町村」と「それ以降」に分割する関数。
         * @param {string} fullAddress - 完全な住所文字列。
         * @returns {object} address1 (都道府県＋市区町村), address2 (それ以降の住所) を含むオブジェクト。
         */
        function splitAddressIntoPrefCityAndRest(fullAddress) {
            let prefCityPart = '';
            let restOfAddress = String(fullAddress).normalize('NFKC'); // NFKC正規化

            // 都道府県を抽出
            const prefRegex = /^(東京都|北海道|(?:京都|大阪)府|.{2,3}県)/;
            const prefMatch = restOfAddress.match(prefRegex);
            if (prefMatch) {
                prefCityPart += prefMatch[0];
                restOfAddress = restOfAddress.substring(prefMatch[0].length);
            }

            // 市区町村を抽出 (郡を含む場合も考慮)
            // 最長の市区町村名を先にマッチさせるために、市、区、町、村の順で試す
            const cityWardPattern = /^((?:.+?郡)?(?:.+?(?:市|区|町|村)))/;
            const cityWardMatch = restOfAddress.match(cityWardPattern);

            if (cityWardMatch) {
                prefCityPart += cityWardMatch[0];
                restOfAddress = restOfAddress.substring(cityWardMatch[0].length);
            }

            // 残りの住所から、全角数字と全角ハイフンを半角に変換
            restOfAddress = restOfAddress.replace(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
            restOfAddress = restOfAddress.replace(/[\uFF0D\u30FC]/g, '-');

            // 住所1と住所2が空になるのを防ぐためのトリム
            prefCityPart = prefCityPart.trim();
            restOfAddress = restOfAddress.trim();

            return {
                address1: prefCityPart,
                address2: restOfAddress
            };
        }


        // 都道府県名と市区町村名、町域を抽出するヘルパー関数
        // この関数は、郵便番号検索APIに渡すための「純粋な町名」を抽出することを目的としています。
        function getPrefCityWardAndRemainingForLookup(fullAddress) {
            let pref = '';
            let cityWard = '';
            let town = '';
            let remainingAddress = String(fullAddress).normalize('NFKC'); // NFKC正規化を先行

            // 全角数字と全角ハイフンを半角に変換
            remainingAddress = remainingAddress.replace(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)); 
            remainingAddress = remainingAddress.replace(/[\uFF0D\u30FC]/g, '-'); // 全角ハイフンマイナスと長音符の両方を変換

            console.log(`getPrefCityWardAndRemainingForLookup: Normalized input address for parsing: "${remainingAddress}"`);

            // 都道府県を検出 (東京都, 北海道, 京都府, 大阪府, XX県)
            const prefRegex = /^(東京都|北海道|(?:京都|大阪)府|.{2,3}県)/;
            const prefMatch = remainingAddress.match(prefRegex);
            if (prefMatch) {
                pref = prefMatch[0];
                remainingAddress = remainingAddress.substring(pref.length);
            }

            // 市区町村を検出 (市, 区, 町, 村 で終わる)
            // 市区町村名には郡名が含まれる場合がある（例：西多摩郡日の出町）
            const cityWardRegex = /^((?:.+?郡)?(?:.+?(?:市|区|町|村)))/; 
            const cityWardMatch = remainingAddress.match(cityWardRegex);

            if (cityWardMatch) {
                cityWard = cityWardMatch[1]; 
                remainingAddress = remainingAddress.substring(cityWard.length);
            }

            // 残りの住所（町域＋番地等）から町域のみを抽出
            let townCandidate = remainingAddress.trim();

            // 括弧内の情報（例：(その他)）を除去
            townCandidate = townCandidate.replace(/（[^）]+）/g, '').replace(/\([^)]+\)/g, '').trim();

            // 数字とハイフン、番地、号、階、ビル名、方書などの詳細部分を町名から除去
            // この正規表現は、町名の末尾にある可能性のある「数字を含む詳細情報」を除去することを目指します。
            // 例: "篠崎町7-27-19" -> "篠崎町"
            // 例: "丸の内1丁目1番地1号" -> "丸の内1丁目"
            // 例: "日本橋室町四丁目一番地" -> "日本橋室町四丁目"
            // 例: "大手町1-1" -> "大手町"
            // 以下のパターンは、町名の後に続く番地、号、またはハイフンでつながる数字の塊を検出して除去します。
            // - 数字とそれに続く番地、号、階、ビル名、方書など
            // - ハイフンで繋がれた数字（例: 7-27-19）
            // - 数字のみで構成される末尾部分
            const detailedAddressRegex = /([０-９0-9]+[番地号階]?[-－ー]?[０-９0-9]+.*|[０-９0-9]+[番地号階].*|[-－ー][０-９0-9]+.*|\d+[-]+\d+.*|[０-９0-9]+.*)$/;
            
            // 全角数字と全角ハイフンを半角に変換してから除去
            let tempTownForStrip = townCandidate.replace(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
            tempTownForStrip = tempTownForStrip.replace(/[\uFF0D\u30FC]/g, '-');

            let strippedTown = tempTownForStrip.replace(detailedAddressRegex, '').trim();
            
            // strippedTownが空になった場合、townCandidate全体を再度確認（地番のみの町名など）
            if (!strippedTown && townCandidate.length > 0) {
                // 例外的なケース（例：町名が数字から始まる場合など）
                strippedTown = townCandidate.match(/^(.*?)(?:(?:\d+[丁目番地号])|(?:\d+-\d+)|$)/)?.[1] || townCandidate;
            }

            // 最終的な町名として採用
            town = strippedTown;

            console.log(`getPrefCityWardAndRemainingForLookup: Parsed - Pref: "${pref}", City: "${cityWard}", Town: "${town}" (for API)`);
            return { pref, city: cityWard, town: town };
        }


        // 市区町村コードを取得する関数
        function getCityCode(address) {
            if (cityCodesData.length === 0) {
                console.warn('市区町村コードデータが読み込まれていません。市区町村コードの取得機能は利用できません。');
                return 'データなし';
            }
            // 住所から都道府県と市区町村のみを抽出（郵便番号検索APIの町域抽出とは異なるロジック）
            let prefForCityCode = '';
            let cityForCityCode = '';
            // NFKC正規化を適用
            let tempAddress = String(address).normalize('NFKC');

            const prefRegex = /^(東京都|北海道|(?:京都|大阪)府|.{2,3}県)/;
            const prefMatch = tempAddress.match(prefRegex);
            if (prefMatch) {
                prefForCityCode = prefMatch[0];
                tempAddress = tempAddress.substring(prefForCityCode.length);
            }

            const cityWardRegex = /^((?:.+?郡)?(?:.+?(?:市|区|町|村)))/; 
            const cityWardMatch = tempAddress.match(cityWardRegex);
            if (cityWardMatch) {
                cityForCityCode = cityWardMatch[1]; 
            }

            if (!prefForCityCode || !cityForCityCode) {
                console.warn(`住所から都道府県または市区町村を特定できませんでした（市区町村コード検索用）: "${address}"`);
                return '不明';
            }

            // 市区町村データからコードを検索
            const found = cityCodesData.find(item => {
                const itemPref = String(item['pref'] || '').trim(); 
                const itemCity = String(item['city'] || '').trim(); 
                
                const prefMatch = itemPref === prefForCityCode;
                const cityMatch = (itemCity && (itemCity === cityForCityCode || cityForCityCode.startsWith(itemCity))); 
                return prefMatch && cityMatch;
            });

            if (found && found['code']) { 
                const paddedCode = String(found['code']).padStart(5, '0'); 
                return paddedCode;
            } else {
                console.warn(`住所 "${address}" (都道府県: "${prefForCityCode}", 市区町村: "${cityForCityCode}") に対応する市区町村コードが見つかりません。`);
                return '不明';
            }
        }


        // 国土地理院のAPIで緯度経度を取得する関数
        async function getLatLonAndGSIAddressTitle(address) {
            if (!address) {
                return { latitude: '', longitude: '', gsiAddressTitle: '' };
            }

            // NFKC正規化を適用してからエンコード
            const normalizedAddressForAPI = String(address).normalize('NFKC');
            const encodedAddress = encodeURIComponent(normalizedAddressForAPI);
            const apiUrl = `https://msearch.gsi.go.jp/address-search/AddressSearch?q=${encodedAddress}`;
            console.log(`国土地理院API: Calling API with URL: ${apiUrl}`);

            try {
                const response = await fetch(apiUrl);
                const data = await response.json();
                console.log(`国土地理院APIレスポンス (${address}):`, data);

                if (!response.ok) {
                    console.error(`国土地理院APIリクエスト失敗: ${response.status} ${response.statusText} for address: ${address}`);
                    return { latitude: 'エラー', longitude: 'エラー', gsiAddressTitle: 'エラー' };
                }

                if (data && data.length > 0 && data[0].geometry && data[0].geometry.coordinates) {
                    const longitude = data[0].geometry.coordinates[0];
                    const latitude = data[0].geometry.coordinates[1];
                    const gsiAddressTitle = data[0].properties ? data[0].properties.title : ''; // 国交省住所1用
                    return { latitude, longitude, gsiAddressTitle };
                } else {
                        console.warn(`住所 "${address}" の緯度経度または国交省住所が見つかりませんでした（APIレスポンスデータ不足）。`);
                    return { latitude: '見つかりません', longitude: '見つかりません', gsiAddressTitle: '見つかりません' };
                }
            } catch (error) {
                console.error(`住所 "${address}" の国土地理院APIからの緯度経度・コード取得中にエラーが発生しました:`, error);
                return { latitude: 'エラー', longitude: 'エラー', gsiAddressTitle: 'エラー' }; 
            }
        }

        // HeartRails Geo API を使用して緯度経度から都道府県名を取得する関数
        async function getPrefectureNameFromCoordinates(latitude, longitude) {
            if (latitude === null || longitude === null || isNaN(latitude) || isNaN(longitude)) {
                return '';
            }
            const baseUrl = 'https://geoapi.heartrails.com/api/json';
            const queryParams = new URLSearchParams({
                method: 'searchByGeoLocation',
                x: longitude,
                y: latitude
            });
            const apiUrl = `${baseUrl}?${queryParams.toString()}`;

            try {
                const response = await fetch(apiUrl);
                const data = await response.json();
                if (response.ok && data.response && Array.isArray(data.response.location) && data.response.location.length > 0) {
                    return String(data.response.location[0].prefecture || '').trim();
                } else {
                    return '';
                }
            } catch (error) {
                console.error(`都道府県名取得API呼び出しエラー (Lat: ${latitude}, Lon: ${longitude}):`, error);
                return '';
            }
        }

        // 駅データを外部から読み込む関数 (GeoJSON対応)
        async function loadStationsData() {
            showMessage('駅データを読み込み中...（駅名の重複判定中）', 'info');
            try {
                const response = await fetch(stationsDataUrl);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Fetch response not OK:', response.status, response.statusText, 'Body:', errorText);
                    throw new Error(`ネットワークエラー: ${response.status} ${response.statusText}. URLまたはネットワーク接続を確認してください。`);
                }
                
                let geoJson;
                try {
                    geoJson = await response.json();
                    console.log('GeoJSONを正常にパースしました:', geoJson); 
                } catch (jsonError) {
                    console.error('GeoJSONのパース中にエラー:', jsonError);
                    throw new Error(`GeoJSONファイル形式が不正です。ファイルが破損しているか、有効なGeoJSON形式ではありません。`);
                }

                if (geoJson && geoJson.features && geoJson.features.length > 0) {
                    // 駅名 -> 駅オブジェクトの配列 (重複判定用)
                    const stationNameInstancesMap = new Map();

                    // 1. まずGeoJSONをパースし、駅名と緯度経度を抽出
                    geoJson.features.forEach(feature => {
                        let longitude = null;
                        let latitude = null;

                        if (feature.geometry && feature.geometry.coordinates) {
                            if (feature.geometry.type === "Point") {
                                longitude = feature.geometry.coordinates[0];
                                latitude = feature.geometry.coordinates[1];
                            } else if (feature.geometry.type === "LineString") {
                                if (feature.geometry.coordinates.length > 0) {
                                    longitude = feature.geometry.coordinates[0][0];
                                    latitude = feature.geometry.coordinates[0][1];
                                }
                            } else if (feature.geometry.type === "MultiLineString") {
                                if (feature.geometry.coordinates.length > 0 && feature.geometry.coordinates[0].length > 0) {
                                    longitude = feature.geometry.coordinates[0][0][0];
                                    latitude = feature.geometry.coordinates[0][0][1];
                                }
                            }
                        }

                        const station_name = feature.properties ? String(feature.properties.N02_005 || '').trim() : '不明な駅名';
                        
                        if (typeof latitude === 'number' && typeof longitude === 'number' && !isNaN(latitude) && !isNaN(longitude)) {
                            if (!stationNameInstancesMap.has(station_name)) {
                                stationNameInstancesMap.set(station_name, []);
                            }
                            // ここではまだ prefecture_name は空
                            stationNameInstancesMap.get(station_name).push({ station_name, latitude, longitude, prefecture_name: '' }); 
                        } else {
                            console.warn(`駅名 "${station_name}" のGeoJSONに無効な緯度経度が見つかりました. この駅はスキップされます。`);
                        }
                    });

                    // 2. 駅名が重複している駅に限り、都道府県名を取得
                    const stationsToFetchPref = [];
                    stationNameInstancesMap.forEach((instances, stationName) => {
                        if (instances.length > 1) { // 駅名が重複している場合のみ
                            instances.forEach(instance => {
                                stationsToFetchPref.push(instance);
                            });
                        }
                    });

                    let processedCountForPref = 0;
                    if (stationsToFetchPref.length > 0) {
                        showMessage(`駅データ読み込み中...（重複駅の都道府県名を取得中: ${stationsToFetchPref.length} 件）`, 'info');
                        for (const station of stationsToFetchPref) {
                            if (typeof station.latitude === 'number' && typeof station.longitude === 'number' && !isNaN(station.latitude) && !isNaN(station.longitude)) {
                                station.prefecture_name = await getPrefectureNameFromCoordinates(station.latitude, station.longitude);
                                await delay(50); // API呼び出しごとに遅延
                            }
                            processedCountForPref++;
                            updateProgressBar((processedCountForPref / stationsToFetchPref.length) * 100);
                        }
                    } else {
                        showMessage('駅データ読み込み中...（重複する駅名はありませんでした）', 'info');
                        updateProgressBar(100);
                    }

                    // 3. 最終的な stationsData を構築し、ambiguousStationNames を確定
                    stationsData = Array.from(stationNameInstancesMap.values()).flat(); // 全ての駅インスタンスをフラットな配列にする

                    ambiguousStationNames.clear(); 
                    const tempStationNamePrefecturesMap = new Map(); // 駅名 -> Set<都道府県名> のマップ

                    stationsData.forEach(station => {
                        if (station.prefecture_name) { // 都道府県名が取得できた駅のみ
                            if (!tempStationNamePrefecturesMap.has(station.station_name)) {
                                tempStationNamePrefecturesMap.set(station.station_name, new Set());
                            }
                            tempStationNamePrefecturesMap.get(station.station_name).add(station.prefecture_name);
                        }
                    });

                    tempStationNamePrefecturesMap.forEach((prefecturesSet, stationName) => {
                        if (prefecturesSet.size > 1) { // 複数の都道府県に同じ駅名が存在する場合
                            ambiguousStationNames.add(stationName);
                        }
                    });
                    console.log('重複する駅名リスト (異なる都道府県に存在する):', Array.from(ambiguousStationNames));

                    if (stationsData.length > 0) {
                        showMessage(`駅データ ${stationsData.length} 件の読み込みと重複駅名判定が完了しました。`, 'success');
                    } else {
                        showMessage('GeoJSONファイルには有効な駅データが含まれていませんでした。緯度経度情報が正しいか、サポートされているgeometryタイプか確認してください。', 'error');
                        stationsData = [];
                    }
                } else {
                    showMessage('GeoJSONファイルが空か、形式が不正です。GeoJSONファイルに "features" 配列が含まれているか、またはその配列が空でないか確認してください。', 'error');
                    stationsData = [];
                }
            } catch (error) {
                console.error('駅データ読み込み中に致命的なエラー:', error);
                showMessage(`駅データを読み込めませんでした: ${error.message} ネットワーク接続またはURL、GeoJSONファイルの構造を確認してください。`, 'error');
                stationsData = [];
            } finally {
                // 最終的なプログレスバーは必ず100%にする
                updateProgressBar(100); 
            }
        }

        // 市区町村コードデータを外部から読み込む関数 (CSV対応)
        async function loadCityCodesData() {
            showMessage('市区町村コードデータを読み込み中...', 'info');
            try {
                const response = await fetch(cityCodesDataUrl);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Fetch response not OK for city codes:', response.status, response.statusText, 'Body:', errorText);
                    throw new Error(`市区町村コードデータ読み込みエラー: ${response.status} ${response.statusText}. URLまたはネットワーク接続を確認してください。`);
                }
                const csvText = await response.text();
                // PapaParseを使用してCSVをパース
                cityCodesData = Papa.parse(csvText, { header: true, skipEmptyLines: true }).data; 
                console.log('市区町村コードデータ読み込み完了:', cityCodesData.length, '件');
                if (cityCodesData.length > 0) {
                    showMessage(`市区町村コードデータ ${cityCodesData.length} 件を読み込みました。`); // タイプを info に戻し、件数を明示
                } else {
                    showMessage('市区町村コードデータは読み込まれましたが、有効なデータが含まれていませんでした。CSVファイルの内容を確認してください。', 'error');
                }

            } catch (error) {
            }
        }


        /**
         * ハバーサインの公式を使って2点間の距離をキロメートルで計算する関数
         * @param {number} lat1 - 1点目の緯度
         * @param {number} lon1 - 1点目の経度
         * @param {number} lat2 - 2点目の緯度
         * @param {number} lon2 - 2点目の経度
         * @returns {number} 2点間の距離 (km)
         */
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // 地球の半径 (km)
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // 距離 (km)
        }


        // 緯度経度取得ボタンクリックイベントリスナー
        geocodeButton.addEventListener('click', async () => {
            const addressColumnName = addressColumnInput.value.trim(); // 入力された列名もトリム
            const kanaSuffix = kanaSuffixInput.value.trim(); // 新しい入力フィールドから値を取得
            const selectedOutputFormat = outputFormatSelect.value; // 追加: 選択された出力形式

            if (!addressColumnName) {
                showMessage('住所の列名を入力してください。', 'error');
                return;
            }
            if (parsedData.length === 0) {
                showMessage('CSVファイルを読み込んでください。', 'error');
                return;
            }
            // `includes`の代わりに`some`と厳密な比較を使用して、ヘッダーに完全に一致するものが存在するかを確認
            if (!headers.some(h => h === addressColumnName)) {
                showMessage(`指定された列名 "${addressColumnName}" がCSVヘッダーに見つかりません。`, 'error');
                return;
            }

            // UIの状態を更新（処理中）
            geocodeButton.disabled = true;
            downloadCsvButton.disabled = true;
            cancelButton.classList.remove('hidden'); // キャンセルボタンを表示
            cancelButton.disabled = false; // キャンセルボタンを有効化

            isProcessingCancelled = false; // キャンセルフラグをリセット
            showMessage('緯度経度と最寄り駅を取得中です...（時間がかかる場合があります）', 'info');
            updateProgressBar(0);

            resultData = [];
            // 選択された出力形式に応じてヘッダーを設定
            const currentOutputHeaders = (selectedOutputFormat === 'RMSA') ? RMSA_HEADERS : PILOT_HEADERS;
            resultData.push(currentOutputHeaders.join(',')); // 出力ヘッダー行を追加

            const totalAddresses = parsedData.length;
            let processedCount = 0;

            for (let i = 0; i < totalAddresses; i++) {
                if (isProcessingCancelled) { // キャンセルフラグが立っていたら中断
                    showMessage('処理がユーザーによってキャンセルされました。', 'warning');
                    break; 
                }

                const row = parsedData[i];
                const inputAddress = row[addressColumnName]; // ジオコーディングに使用する元の住所

                // 住所のハイフン表記を変換
                const normalizedAddress = normalizeAddressHyphens(inputAddress);
                console.log(`元の住所: "${inputAddress}" -> 変換後住所: "${normalizedAddress}"`);

                // 国土地理院APIから緯度経度と国交省住所1を取得
                const { latitude, longitude, gsiAddressTitle } = await getLatLonAndGSIAddressTitle(normalizedAddress);
                
                // --- 最寄り駅の検索 ---
                let nearestStationNameValue = '';

                // 緯度経度が有効な数値で、かつ駅データが読み込まれている場合にのみ最寄り駅を検索
                if (stationsData.length > 0 && typeof latitude === 'number' && typeof longitude === 'number' && !isNaN(latitude) && !isNaN(longitude)) {
                    let minDistance = Infinity;
                    let nearestStation = null;

                    for (const station of stationsData) {
                        // 緯度経度が数値であることを確認
                        if (typeof station.latitude === 'number' && typeof station.longitude === 'number' && !isNaN(station.latitude) && !isNaN(station.longitude)) {
                            const dist = haversineDistance(latitude, longitude, station.latitude, station.longitude);
                            if (dist < minDistance) {
                                minDistance = dist;
                                nearestStation = station;
                            }
                        }
                    }
                    if (nearestStation) {
                        nearestStationNameValue = nearestStation.station_name;
                        // 異なる都道府県に同名駅が存在する場合のみ、その駅の都道府県名を付加
                        if (ambiguousStationNames.has(nearestStation.station_name)) {
                            if (nearestStation.prefecture_name) {
                                nearestStationNameValue += ` (${nearestStation.prefecture_name})`;
                            } else {
                                // 万が一、都道府県名が取得できなかった場合のフォールバック
                                nearestStationNameValue += ` (同名駅あり)`; 
                            }
                        }
                    }
                } else if (stationsData.length === 0) {
                    nearestStationNameValue = '駅データなし';
                } else {
                    nearestStationNameValue = '住所不明';
                }

                // --- 市区町村コードの取得 --- (PILOTのみで使用)
                let cityCodeValue = '';
                if (selectedOutputFormat === 'PILOT') {
                    if (cityCodesData.length > 0) {
                        cityCodeValue = getCityCode(normalizedAddress);
                    } else {
                        cityCodeValue = 'データなし';
                    }
                }

                // --- 郵便番号の取得 ---
                // まず住所文字列から直接抽出を試みる
                let postalCodeValue = extractPostalCodeFromAddressString(inputAddress); 

                // 直接抽出できなかった場合、HeartRails APIを使って緯度経度から郵便番号を検索
                if ((!postalCodeValue || postalCodeValue === '不明') && typeof latitude === 'number' && typeof longitude === 'number' && !isNaN(latitude) && !isNaN(longitude)) {
                    postalCodeValue = await getPostalCodeFromHeartRailsAPI(latitude, longitude);
                }
                
                // 郵便番号が見つからなければ「不明」または空文字列にする
                if (!postalCodeValue) {
                    postalCodeValue = '不明'; 
                }

                // --- 新しい出力行のデータを構築 ---
                const outputRowValues = {};
                currentOutputHeaders.forEach(header => {
                    outputRowValues[header] = ''; // 全ての出力ヘッダーを初期化
                });

                // 各出力形式に応じたデータ設定
                if (selectedOutputFormat === 'PILOT') {
                    // PILOT出力形式の項目を設定
                    outputRowValues['企業コード'] = row['企業コード'] || '';
                    outputRowValues['店舗コード'] = row['店舗コード'] || '';
                    outputRowValues['ロケール'] = row['ロケール'] || '';
                    outputRowValues['店舗名(漢字)'] = row['店舗名'] || ''; // 入力CSVの'店舗名'を想定
                    outputRowValues['請求先コード1'] = row['請求先コード1'] || '';
                    outputRowValues['請求先コード2'] = row['請求先コード2'] || '';
                    outputRowValues['使用不可フラグ'] = row['使用不可フラグ'] || '';
                    outputRowValues['L2コード'] = row['L2コード'] || '';
                    outputRowValues['住所1'] = row['住所1'] || ''; // 入力CSVの'住所1'をそのまま
                    outputRowValues['住所2'] = row['住所2'] || ''; // 入力CSVの'住所2'をそのまま
                    outputRowValues['住所3'] = row['住所3'] || ''; // 入力CSVの'住所3'をそのまま
                    outputRowValues['電話番号'] = row['電話番号'] || '';
                    outputRowValues['FAX番号'] = row['FAX番号'] || '';
                    outputRowValues['担当部門'] = row['担当部門'] || '';
                    outputRowValues['担当者役職'] = row['担当者役職'] || '';
                    outputRowValues['担当者名'] = row['担当者名'] || '';
                    outputRowValues['担当者MAIL'] = row['担当者MAIL'] || '';
                    outputRowValues['代表業態コード'] = row['代表業態コード'] || '';
                    outputRowValues['業態中分類コード'] = row['業態中分類コード'] || '';
                    outputRowValues['旧業態コード'] = row['旧業態コード'] || '';
                    outputRowValues['旧業態コード中分類'] = row['旧業態コード中分類'] || '';
                    outputRowValues['管轄DOコード'] = row['管轄DOコード'] || '';
                    outputRowValues['添付ファイルコード'] = row['添付ファイルコード'] || '';
                    outputRowValues['ファイル名'] = row['ファイル名'] || '';
                    outputRowValues['ファイルアップロード日'] = row['ファイルアップロード日'] || '';
                    outputRowValues['SEJDO名'] = row['SEJDO名'] || '';
                    outputRowValues['免許品'] = row['免許品'] || '';
                    outputRowValues['実績年月日1'] = row['実績年月日1'] || '';
                    outputRowValues['実績作業量1'] = row['実績作業量1'] || '';
                    outputRowValues['実績年月日2'] = row['実績年月日2'] || '';
                            outputRowValues['実績作業量2'] = row['実績作業量2'] || '';
                    outputRowValues['実績年月日3'] = row['実績年月日3'] || '';
                    outputRowValues['実績作業量3'] = row['実績作業量3'] || '';
                    outputRowValues['登録日時'] = row['登録日時'] || '';
                    outputRowValues['登録ユーザID'] = row['登録ユーザID'] || '';
                    outputRowValues['更新日時'] = row['更新日時'] || '';
                    outputRowValues['更新ユーザID'] = row['更新ユーザID'] || '';

                    // マッピングされる項目 (入力CSVのヘッダーが異なる場合)
                    outputRowValues['顧客側店舗コード'] = row['顧客店番'] || '';

                    // APIから取得・加工する項目
                    outputRowValues['郵便番号'] = postalCodeValue;
                    outputRowValues['国交省住所1'] = gsiAddressTitle;
                    if (gsiAddressTitle === '見つかりません' || gsiAddressTitle === 'エラー') {
                        // 国交省住所が取得できなかった場合、入力住所をPILOTの住所1に格納
                        outputRowValues['住所1'] = inputAddress; 
                    }
                    outputRowValues['市区町村コード'] = cityCodeValue;
                    outputRowValues['緯度'] = latitude;
                    outputRowValues['経度'] = longitude;
                    outputRowValues['鉄道最寄駅'] = nearestStationNameValue;
                    outputRowValues['バス最寄駅'] = ''; // 現在、バス最寄駅の取得機能は未実装

                    // 店舗名(カナ)の変換とサフィックス付与
                    const originalKanaValuePilot = row['フリガナ'] || row['店舗名(カナ)'] || row['店舗名'] || ''; // 複数の可能性を考慮
                    let processedKanaValuePilot = toHalfWidthKatakana(String(originalKanaValuePilot));
                    if (kanaSuffix) { processedKanaValuePilot += kanaSuffix; }
                    outputRowValues['店舗名(カナ)'] = processedKanaValuePilot;

                } else if (selectedOutputFormat === 'RMSA') {
                    // RMSA出力形式の項目を設定
                    outputRowValues['企業CD'] = row['企業コード'] || '';
                    outputRowValues['店舗CD'] = row['店舗コード'] || '';
                    outputRowValues['店舗名'] = row['店舗名'] || ''; // RMSAの店舗名は入力CSVの店舗名（漢字）を想定
                    outputRowValues['顧客側店舗CD'] = row['顧客店番'] || ''; // 入力CSVの'顧客店番'をマッピング
                    
                    // APIから取得・加工する項目
                    outputRowValues['郵便番号'] = postalCodeValue;
                    
                    // 住所の分割
                    const { address1, address2 } = splitAddressIntoPrefCityAndRest(inputAddress);
                    outputRowValues['住所1'] = address1; // 市区町村まで
                    outputRowValues['住所2'] = address2; // それ以降
                    outputRowValues['住所3'] = ''; // RMSAの住所3は現状空欄

                    outputRowValues['電話番号'] = row['電話番号'] || '';
                    outputRowValues['FAX番号'] = row['FAX番号'] || '';
                    outputRowValues['最寄り駅'] = nearestStationNameValue; // PILOTの鉄道最寄駅と同じ値
                    outputRowValues['最寄りバス停'] = ''; // 現在、バス最寄り駅の取得機能は未実装
                    outputRowValues['削除フラグ'] = row['使用不可フラグ'] || ''; // 入力CSVの'使用不可フラグ'をマッピング
                    outputRowValues['緯度'] = latitude;
                    outputRowValues['経度'] = longitude;
                }


                // CSV形式に変換してresultDataに追加
                const csvRow = currentOutputHeaders.map(header => {
                    let value = outputRowValues[header];

                    // 郵便番号と市区町村コードの頭0欠落対策 (Excelで文字列として認識させる)
                    // value が null や undefined でないことを確認してから toString() を呼び出す
                    if (header === '郵便番号' || (header === '市区町村コード' && selectedOutputFormat === 'PILOT')) {
                        // 郵便番号は既に「000-0000」形式になっているため、そのままExcel用にシングルクォーテーションで囲む
                        value = value !== null && value !== undefined ? `'${value.toString()}` : "''"; 
                    }
                    
                    // CSVの値を適切にエスケープ（カンマや引用符、改行を含む場合）
                    if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n') || value.includes('\r'))) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                }).join(',');
                resultData.push(csvRow);


                processedCount++;
                const progress = (processedCount / totalAddresses) * 100;
                updateProgressBar(progress);
            }

            // 処理完了後の状態更新
            geocodeButton.disabled = false;
            cancelButton.classList.add('hidden'); // キャンセルボタンを非表示に
            cancelButton.disabled = true; //念のため無効化

            if (!isProcessingCancelled) {
                showMessage('緯度経度と最寄り駅の取得が完了しました！', 'success');
                downloadCsvButton.disabled = false;
                updateProgressBar(100);
            } else {
                updateProgressBar(processedCount / totalAddresses * 100); // 中断時の進捗で停止
                // 中断メッセージは既に表示されているため、ここでは特にメッセージ更新しない
            }
        });

        // キャンセルボタンクリックイベントリスナー
        cancelButton.addEventListener('click', () => {
            isProcessingCancelled = true;
            cancelButton.disabled = true; // キャンセルボタンを無効化
            geocodeButton.disabled = true; // 処理中断中はジオコーディング開始ボタンも無効化
            showMessage('処理をキャンセルしています...完了までお待ちください。', 'warning');
            // ループが中断された後に、geocodeButtonは自動的に再有効化されます
        });


        // CSVダウンロードボタンクリックイベントリスナー
        downloadCsvButton.addEventListener('click', () => {
            if (resultData.length === 0) {
                showMessage('まず緯度経度と最寄り駅を取得してください。', 'error');
                return;
            }

            const csvContent = resultData.join('\n');
            // ダウンロード時の文字コードはUTF-8-BOMとするのがExcelで文字化けしにくい
            const blob = new Blob(['\ufeff', csvContent], { type: 'text/csv;charset=utf-8;'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // ダウンロードファイル名にバージョンと形式を付加
            const fileNamePrefix = outputFormatSelect.value === 'RMSA' ? 'RMSA用' : 'PILOT用';
            a.download = `${fileNamePrefix}_データ_変換済み_${APP_VERSION}.csv`; 
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url); // 不要になったURLを解放
            showMessage('CSVファイルをダウンロードしました。', 'success')
        });

        // 初期状態
        csvFileInput.disabled = true; // 駅データ読み込みまで無効化
        geocodeButton.disabled = true;
        downloadCsvButton.disabled = true;
        cancelButton.classList.add('hidden'); // キャンセルボタンは初期状態で非表示
    </script>
</body>
</html>
